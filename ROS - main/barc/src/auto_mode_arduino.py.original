#!/usr/bin/python
import rospy
from geometry_msgs.msg import Vector3, Twist
from data_service.msg import TimeData
from math import pi,sin
import time
import serial

# communication scheme
# ODROID -> Arduino -> actuators (servo, motor)

SPD         = 99       	        # initial speed PWN signal value
BRAKE       = 50         	# brake PWN signal value 
NEUTRAL     = 90         	# neutral PWN signal value 
STOPPED     = False

# Initialize serial connection
ser = serial.Serial(port = '/dev/ttyUSB0',baudrate = 115200)
if ser.isOpen():
    ser.close()
ser.open()
ser.write("90,90f") #for phyton 3 useser.write("90,90f".encode())


# open file for data collection
BASE_PATH   		= "/home/odroid/Data/"
data_file_name   	= BASE_PATH + time.strftime("%Y-%m-%d_%H-%M-%S") + '.csv'
data_file     		= open(data_file_name, 'a')
data_file.write('t_s,roll,pitch,yaw,a_x,a_y,a_z,w_x,w_y,w_z,vx_est,vy_est,X_est,Y_est,d_F,FxR,vx_enc, enc_count\n')

# input commands
d_F 	= 0
FxR     = 0
vx_enc = 0
new_enc_pos = 0

#############################################################
# [deg] -> [PWM]
def angle_2_servo(x):
    u   = 92.0558 - 1.8194*x  - 0.0104*x**2
    return u

# [PWM] -> [deg]
def servo_2_angle(x):
    d_F   = 39.2945 - 0.3018*x  - 0.0014*x**2
    return d_F
L_TURN 	    = angle_2_servo(20) 
R_TURN 	    = angle_2_servo(-20)
Z_TURN 	    = angle_2_servo(0)

#############################################################
def saveData_callback(data):
	all_data = (time.time(),) + tuple(data.value) + (d_F, FxR,vx_enc, new_enc_pos)
	data_file.write('%.3f,%.2f,%.2f,%.4f,%.4f,%.4f,%.4f,%.4f,%.4f,%.4f,%.4f,%.4f,%.4f,%.4f, %.3f, %.3f, %.3f, %d\n' % all_data)

#############################################################
def CircularTest(t_i, rate):
    oneSec 	= rate
    t_0         = 3
    t_f         = t_0 + 15*oneSec

    # do nothing initially
    if (t_i < t_0):
        SPEEDcmd        = NEUTRAL
        TURNcmd         = Z_TURN
    # turn left and move
    elif (t_i >= t_0) and (t_i <= t_f):
        TURNcmd     = angle_2_servo(25)
        SPEEDcmd    = SPD
    # set straight and stop
    else:
        TURNcmd     = Z_TURN
        SPEEDcmd        = NEUTRAL
        global STOPPED
        if not STOPPED:
            SPEEDcmd    = BRAKE
            STOPPED     = True

    return (TURNcmd, SPEEDcmd)

#############################################################
def Straight(t_i, rate):
    # timing maneuvers
    oneSec      = rate
    dt          = 2*oneSec 
    t_0         = 2
    t_f         = t_0 + dt

    # stop moving
    if t_i < t_0:
        TURNcmd     = 92
        SPEEDcmd    = 90
    # start moving
    elif (t_i >= t_0) and (t_i < t_f):
        TURNcmd     = 92
        SPEEDcmd    = 95
    # stop
    else:
        TURNcmd     = Z_TURN
        SPEEDcmd    = NEUTRAL
        global STOPPED
        if not STOPPED:
            SPEEDcmd    = BRAKE
            STOPPED     = True

    return (TURNcmd, SPEEDcmd)

#############################################################
def SineSweep(t_i, rate):
    # timing maneuvers
    oneSec      = rate
    dt          = 2.5*oneSec 
    t_0         = 5*oneSec
    start_turning = 1*oneSec
    t_st         = t_0+start_turning
    t_f         = t_0 + dt +start_turning
    T           = 1.2*oneSec

    # start moving
    if  (t_i<t_0):
        TURNcmd     = Z_TURN
        SPEEDcmd    = NEUTRAL
    elif  (t_i >= t_0) and (t_i < t_st):
        TURNcmd     = Z_TURN
        SPEEDcmd    = SPD	
    elif  (t_i >= t_st) and (t_i < t_f):
        TURNcmd     = angle_2_servo(25*sin(2*pi*(t_i-t_0)/float(T)))
        SPEEDcmd    = SPD
    # stop
    else:
        TURNcmd     = Z_TURN
        SPEEDcmd    = BRAKE
 

    return (TURNcmd, SPEEDcmd)


#############################################################
def DoubleLaneChange(t_i, rate):
    # timing maneuvers
    oneSec      = rate
    dt          = 2*oneSec 
    t_0         = 2
    t_LT        = t_0 + dt
    t_RT        = t_LT + dt
    t_ZT        = t_RT + dt
    t_f         = t_ZT + dt

    # start moving
    if t_i < t_0:
        TURNcmd     = Z_TURN
        SPEEDcmd    = SPD
    # turn left
    elif (t_i >= t_0) and (t_i < t_LT):
        TURNcmd     = L_TURN
        SPEEDcmd    = SPD
    # turn right
    elif (t_i >= t_LT) and (t_i < t_RT):
        TURNcmd     = R_TURN
        SPEEDcmd    = SPD
    # go straight
    elif (t_i >= t_RT) and (t_i < t_ZT):
        TURNcmd     = Z_TURN
        SPEEDcmd    = SPD
    # stop
    else:
        TURNcmd     = Z_TURN
        SPEEDcmd    = NEUTRAL
        global STOPPED
        if not STOPPED:
            SPEEDcmd    = BRAKE
            STOPPED     = True

    return (TURNcmd, SPEEDcmd)


#############################################################
def main_auto():
    rospy.init_node('auto_mode', anonymous=True)
    rospy.Subscriber('imu_data',TimeData, saveData_callback)

    # specify tests
    test_opt    = { 0 : CircularTest,
                    1 : DoubleLaneChange,
                    2 : Straight,
		    3 : SineSweep   }

    test_sel    = 0
    test_mode   = test_opt.get(test_sel)

    rateHz=50 
    rate 	= rospy.Rate(rateHz)		# set the rate to one Hert
    t_i         = 0
     
    global d_F, FxR, vx_enc, new_enc_pos
    # Old encoder Position
    old_enc_pos=0
    vx_enc=0
    radius=0.036*2*pi
    
    while not rospy.is_shutdown():
        # determine inputs
        (TURNcmd, SPEEDcmd) = test_mode(t_i, rateHz)
	d_F 	= servo_2_angle(TURNcmd)
	FxR     = SPEEDcmd

        # send command signal 
        ser.write(str(SPEEDcmd)+','+str(int(TURNcmd))+'f') 
        #print(str(SPEEDcmd)+','+str(int(TURNcmd))+'f') 

        # read encoders and estimate speed
        a = ser.inWaiting()
        b = ser.read(a).splitlines()
        if (len(b)>1):
                #new_enc_pos=(int(b[-2])+int(b[-3]))/2
		new_enc_pos = int(b[-2])
        else:
                new_enc_pos=old_enc_pos
        vx_enc=(new_enc_pos-old_enc_pos)*radius*rateHz/8 #/2 because now the arduisno sends out he sum of the encoders       
	old_enc_pos = new_enc_pos
                
        # increment counter, and wait
        t_i += 1 
        rate.sleep()

#############################################################
if __name__ == '__main__':
    print('I am here')
    try:
        main_auto()
    except rospy.ROSInterruptException:
        pass
